I created xdAGamma.py based on xdGamma.py with the help of Jo.
Jo sent me the following files. These files contain the samples. 
powerlawSF_r.sav
star_powerlawSF_r_k1g1wt.sav
rrlyrae_powerlawSF_r.sav

I used xdAGamma.py on these files to obtain the best-fit Gaussians for the samples of qsos, stars, and rrlyraes. The most suitable numbers seemed to be k=3, g=3 after quite abt of trial and error. We also needed to make small changes in xdAGamma.py to add weights to the samples. That is why the outputs have the letter "wt" in them. 
python xdAGamma.py -k 3 -g 3 ../../powerlawSF_r.sav -o ../../powerlawSF_r_k3g3wt.sav

will take the samples in ../../powerlawSF_r.sav, fit each quasar's samples with g=3 Gaussians, and deconvolve the gamma distribution of all quasars with k=3 Gaussian. The result is saved in ../../powerlawSF_r_k3g3wt.sav

python xdAGamma.py -k 3 -g 3 ../../powerlawSF_r.sav -o ../../powerlawSF_r_k3g3wt.sav
python xdAGamma.py -k 3 -g 3 ../../star_powerlawSF_r.sav -o ../../star_powerlawSF_r_k3g3wt.sav
python xdAGamma.py -k 3 -g 3 ../../rrlyrae_powerlawSF_r.sav -o ../../rrlyrae_powerlawSF_r_k3g3wt.sav

The xdGamma code does not output the individual fits to the samples of the 9000 quasars, it only outputs the fit of a single distribution at the end (in the above case with -k 3 this is three 3-D Gaussians). If you run with -k 2  you would get the parameters of two Gaussians (the order is amplitudes, means, variances, and the average log likelihood of the fit).

Then the output .sav files can be plotted using the plotXD.py code:
python plotXD.py ../../powerlawSF_r_k3g3wt.sav -o ../../k3g3wt.eps --expd2 --divided1=2. --d1=1 --d2=0
python plotXD.py ../../star_powerlawSF_r_k3g3wt.sav -o ../../stark3g3wt.eps --expd2 --divided1=2. --d1=1 --d2=0
python plotXD.py ../../rrlyrae_powerlawSF_r_k3g3wt.sav -o ../../rrk3g3wt.eps --expd2 --divided1=2. --d1=1 --d2=0

Jo also sent me the following files:
uvx_powerlawSF_r.sav
nuvx_powerlawSF_r.sav
uvx_woname.fit
nUVX_woname.fit

The fit files above are required because we need to re-match to the input catalog to get the RA and Dec that go into OUTPUT.FITS.

Then I use classQSOXD.py to generate the following outputs.
python classQSOXD.py ../../nuvx_powerlawSF_r.sav --qsomodel=../../powerlawSF_r_k3g3wt.sav --starmodel=../../star_powerlawSF_r_k3g3wt.sav --rrlyraemodel=../../rrlyrae_powerlawSF_r_k3g3wt.sav -o output.fits

In the above, the model files were previously generated by xdAGamma.py. The input file, uvx_powerlawSF_r.sav, is the .sav version (python pickle format) of the uvx sample. The same for nuvx sample is nuvx_powerlawSF_r.sav. uvx_woname.fit and nUVX_woname.fit are used inside of classQSOXD.py. 

There were a few edits made to the classQSOXD code.

1. It seems like many of the sources have best-fit logA << typical stellar logA. Those are probably stars, but because our stellar model is so focused on the region near logA ~ -3.5, gamma ~ 0, they get strange probabilities that after normalizing. These strange probabilities often make them seem like quasars. There are two options:

- Add a 'junk' model that tries to sweep up everything with small logA

- Add a cut on the best-fit log A > -3.5.

The latter seems like the easier to implement, so perhaps we should stick to that for now. Jo re-wrote the classQSOXD code to add the best-fit gamma and logA to the output file. We should add the best-fits file as a second argument (after the samples file) for this to work. The output.fits file will then contain entries gamma and loga, which you can then use to do the loga > -3.5 cut. When you have implemented the cut, could you also re-run the uvx selection? (no need to cut that to i > 17.8 and the RA, since the original SDSS is complete over the full stripe-82).

This version is classQSOXD1.py

2. Then another version classQSOXD2.py so that bestfits can be used as both arguments. This is to see the influence of using the sample as opposed to using the best-fit only.

3. classQSOXD3.py is an intermediate version that is not required.

4. The final version to classQSOXD4.py disallow logA values less than -4.6 in classQSOXD itself. Also takes care of the fact that the gamma =~ 0 part of our quasar model is wrong.

Number of sources in the input of classQSOXD is different from that in uvx_woname.fit. I give the number of sources in the relevant files below:
nUVX_woname.fit: 3160
nuvx_powerlawSF_r.sav: 2255
uvx_woname.fit: 2379
uvx_powerlawSF_r.sav : 2133 
The reason that there are fewer sources in the output.fits file is that Jo only processed sources with N_epochs > 20 (appx). Since we want to know how well variability selection does for reasonably well-time-sampled data, that's probably okay.

The output of this step (out_uvx.fits, out_nuvx1.fits, and other variants) contains the variability based probabilities of each source being a qso, star, and rrlyrae. So the output out_uvx.fits is basically a structure that contains all sources of the uvx sample. The structure contains logpx_qso, logpx_star, logpx_rr;yrear for each of those sources. These are the variability based probabilities. They are not normalized. So we have to normalize them, by doing:
pvar_qso=exp(logpx_qso)/[exp(logpx_qso)+exp(logpx_star)+exp(logpx_rrlyrae)]
so that for each source pvar_qso+pvar_star+pvar_rrlyrae=1.0

The above normalization and other steps are done in the idl code class?.pro
In this code, we caculate pvar, pcol (color based probability), and pcolvar (probability based on variability+color). As described already, we get pvar from the output of classQSOXD. We get pcol using xdqsoz_calculate_prob code already installed. But the input of the xdqsoz_calculate_prob code is the colors. Therefore, we obtained the psfflux and psflfux_ivar for all objects using the code collect*.pro. This code takes the SDSS magnitudes from the fits files in git_rit/data/uvx and git_rit/data/nuvx and uses sdss routines for mags--to--flux conversion routines to get the psfflux and the corresponding magerrors to get the psfflux_ivar. These two quantities are the required input of xdqsoz_calculate_prob.

We get pcolvar using pcol, pvar and other parameters using eqn(15) of the draft written by Jo. The "other parameters" are also obtained from xdqsoz_calculate_prob.

In this code we use three quasar catalogs to figure out the actual qsos among our uvx and nuvx samples. These catalogs of (spectroscopically confirmed) qsos are:
data/S82qsos.fits
data/DR9Q.fits
data/2slaq.fits.

We need to be mindful of the following:
1. BOSS quasars are only selected at i > 17.8, so we should cut to that subsample;
2. BOSS stripe-82 observations are 317 < RA < 45, so we should cut to that RA range.


Hi Ritaban,

Thanks for the update. To me it seems like there are two separate issues:

1) The var-only selection for the nUVX sample isn't working quite right (efficiency and completeness were pretty high with the logA > -3.5 cut, but low without it);

2) the color+var selection does not improve the var selection for the UVX sample.

We should try to figure out both of these. For 1) I would suggest that you take the objects that are classified as quasars according to the variability probability but aren't for a threshold near completeness=0.9. You can then look at 

- Their distribution in best-fit logA , gamma (this should be rather straightforward, since that information is in the file generated by classQSOXD.py).

- The distribution of the samples (logA,gamma) for some of these. This is somewhat more complicated, because you will need to dig into the .sav file with the nuvx samples to find these objects. The way to do this would be something like this:

* Ra,Dec match them to the data file (nuvx_woname.fits or something similar to this I think). Then the oname tag in that file should give you the filename in the nuvx/ data directory (the directory with the individual files). You can then open the file that has the nuvx samples (the file that is the input to classQSOXD.py) and load them using

savefile= open(savefilename,'rb')
samples= pickle.load(savefile)
savefile.close()

You can then use the key derived from oname (I think it might be just oname, but it could be that you have to add/remove .fit. Look at samples.keys()[0] to find out the correct format and then fiddle with oname to match that; hopefully that will work). Then you can run through the samples for that key, like in xdAGamma.py, so something like

gammas= []
logAs= []
for sample in samples[key]:
    gammas.append(sample['gamma'][0])
    logAs.append(numpy.log(sample['logA'][0]))/2.

and plot these (just using plot, should work in ipython --pylab) for a few of the objects that are classified as quasars but aren't. 

Hopefully, this will show something that gives us a clue as to what is going wrong.


For 2) we should look a little deeper into what the colors and the variability are telling us. Perhaps you could plot p(color+var) vs. p(color) and also vs. p(var) and that might tell us something? I would do this for the UVX sample, since the problems with color+var were clearer there (you can just use the variability probabilities from before if you haven't rerun UVX with the latest version of the classQSOXD code).

Jo


